import os, sys

from pathlib import Path
path_root = Path(__file__).parents[2]  # upto 'codebase' folder
sys.path.insert(0, str(path_root))
# print(sys.path)

import gc

from utils import dl_reproducible_result_util
from postproc.mat_p2ip_pd.mat_p2ip_pd_postproc_2_mutSeqStructPred_byAf2 import run_postproc_2_mut_seq_struct_pred_by_af2
from postproc.mat_p2ip_pd.mat_p2ip_pd_postproc_5_mutComplexStructPred_byAf2 import run_postproc_5_mut_complx_struct_pred_by_af2


def trigger_pd_postproc(root_path = './', postproc_stage=None, user_input_dict=dict()):
    print('inside trigger_pd_postproc() method - Start')
    print('\n#########################################################')
    print(f'         postproc_stage = {postproc_stage}')
    print('#########################################################')
    print(f'\n ===================\n user_input_dict: \n {user_input_dict}')
    # Create input_dict from user_input_dict.
    # User may chose to provide only a few arguments, required for the experiment.
    # input_dict would contain those user overridden argument values and the rest of the arguments with
    # their default values. In other words, input_dict would contain full set of arguments required for
    # the postprocessing whereas user_input_dict would contain only a subset (which user chose to override) of it.
    input_dict = {'root_path': root_path}

    # location of the downloaded PDB files
    def_pdb_file_location = os.path.join(root_path, "dataset/preproc_data/pdb_files")  # default value
    # check if the user_input_dict contains value for the key 'pdb_file_location'; 
    # otherwise, set it to the default value
    input_dict['pdb_file_location'] = user_input_dict.get('pdb_file_location', def_pdb_file_location)

    # list of dimeric protein complex names to be used as input for the postprocessing after simulation 
    def_dim_prot_complx_nm_lst = ['2I25']  # default value
    # check if the user_input_dict contains value for the key 'dim_prot_complx_nm_lst'; 
    # otherwise, set it to the default value
    input_dict['dim_prot_complx_nm_lst'] = user_input_dict.get('dim_prot_complx_nm_lst', def_dim_prot_complx_nm_lst)

    # Location of the folder in which the postprocessing result will be saved 
    def_postproc_result_dir = os.path.join(root_path, f'dataset/postproc_data/result_dump')  # default value
    # check if the user_input_dict contains value for the key 'postproc_result_dir'; 
    # otherwise, set it to the default value
    input_dict['postproc_result_dir'] = user_input_dict.get('postproc_result_dir', def_postproc_result_dir)

    # Cuda index for GPU. Possible values are 0, 1 for two GPU devices in a single node.
    def_cuda_index = 0  # 0 default value
    # check if the user_input_dict contains value for the key 'cuda_index'; 
    # otherwise, set it to the default value
    input_dict['cuda_index'] = user_input_dict.get('cuda_index', def_cuda_index)

    # Threshold value for the PPI score (actually probability of PPI). For postprocessing, mutated sequences above this threshold will be considered.
    def_ppi_score_threshold = 0.8  # default value
    # check if the user_input_dict contains value for the key 'ppi_score_threshold'; 
    # otherwise, set it to the default value
    input_dict['ppi_score_threshold'] = user_input_dict.get('ppi_score_threshold', def_ppi_score_threshold)

    # Maximum mumber of mutated sequences to be selected out of those having ppi score more than the 'ppi_score_threshold'.
    # The selection will be done in the descending order of the associated ppi score, i.e. the candidate with the highest ppi score would be selected first and so on.
    def_max_num_of_seq_above_ppi_score_threshold = 25
    # check if the user_input_dict contains value for the key 'max_num_of_seq_above_ppi_score_threshold'; 
    # otherwise, set it to the default value
    input_dict['max_num_of_seq_above_ppi_score_threshold'] = user_input_dict.get('max_num_of_seq_above_ppi_score_threshold', def_max_num_of_seq_above_ppi_score_threshold)
    
    # ######################################## AlphaFold2 related parameters -Start ########################################
    # Whether to use SCWRL in place of AF2 for the mutated sequence structure prediction (postproc_stage = '2_mut_seq_struct_pred_by_af2') for the faster prediction at the cost of accuracy
    def_af2_use_scwrl = False
    # check if the user_input_dict contains value for the key 'af2_use_scwrl'; 
    # otherwise, set it to the default value
    input_dict['af2_use_scwrl'] = user_input_dict.get('af2_use_scwrl', def_af2_use_scwrl)

    # Scwrl executable path to be used for the Scwrl execution
    def_scwrl_exec_path = os.path.join('/scratch/pralaycs/Shubh_Working_Remote/SCWRL4/')  # default value
    # check if the user_input_dict contains value for the key 'scwrl_exec_path'; 
    # otherwise, set it to the default value
    input_dict['scwrl_exec_path'] = user_input_dict.get('scwrl_exec_path', def_scwrl_exec_path)
    
    # Execution mode of Alphafold. THere are 3 modes: 
    # 1. msa_gen: In this mode, AF2 execution will produce only MSA files and not any prediction result.
    # 2. pred_a4_msa_gen: In this mode, AF2 will use pre-generated MSA files for the prediction.
    # 3. msa_pred_gen: In this mode, AF2 will first genearate MSA files and after that will do the prediction using those MSA files as an end-to-end process. 
    def_af2_exec_mode = 'msa_pred_gen'
    # check if the user_input_dict contains value for the key 'af2_exec_mode'; 
    # otherwise, set it to the default value
    input_dict['af2_exec_mode'] = user_input_dict.get('af2_exec_mode', def_af2_exec_mode) 
    
    # Number of prediction recycles. Increasing recycles can improve the prediction quality but slows down the prediction.
    def_af2_num_recycle = 10
    # check if the user_input_dict contains value for the key 'af2_num_recycle'; 
    # otherwise, set it to the default value
    input_dict['af2_num_recycle'] = user_input_dict.get('af2_num_recycle', def_af2_num_recycle)

    # Number of ensembles. The trunk of the network is run multiple times with different random choices for the MSA cluster centers. 
    # This can result in a better prediction at the cost of longer runtime. 
    def_af2_num_ensemble = 1
    # check if the user_input_dict contains value for the key 'af2_num_ensemble'; 
    # otherwise, set it to the default value
    input_dict['af2_num_ensemble'] = user_input_dict.get('af2_num_ensemble', def_af2_num_ensemble)

    # Number of seeds to try. Will iterate from range(random_seed, random_seed+num_seeds). This can result in a better/different
    # prediction at the cost of longer runtime. 
    def_af2_num_seeds = 3
    # check if the user_input_dict contains value for the key 'af2_num_seeds'; 
    # otherwise, set it to the default value
    input_dict['af2_num_seeds'] = user_input_dict.get('af2_num_seeds', def_af2_num_seeds)

    # Do not recompute results, if a query has already been predicted. 
    def_af2_overwrite_existing_results = False
    # check if the user_input_dict contains value for the key 'af2_overwrite_existing_results'; 
    # otherwise, set it to the default value
    input_dict['af2_overwrite_existing_results'] = user_input_dict.get('af2_overwrite_existing_results', def_af2_overwrite_existing_results)
    # ######################################## AlphaFold2 related parameters -End ########################################
    
    # Create the input directory for the mutated sequence structure prediction by AlphaFold2
    inp_dir_mut_seq_struct_pred_af2 = os.path.join(root_path, 'dataset/postproc_data/alphafold2_io/mut_seq_struct_pred_inp')

    # Create the output directory for the mutated sequence structure prediction by AlphaFold2
    out_dir_mut_seq_struct_pred_af2 = os.path.join(root_path, 'dataset/postproc_data/alphafold2_io/mut_seq_struct_pred_out')

    # Create the input directory for the mutated complex structure prediction by AlphaFold2
    inp_dir_mut_complx_struct_pred_af2 = os.path.join(root_path, 'dataset/postproc_data/alphafold2_io/mut_complx_struct_pred_inp')
    
    # Create the output directory for the mutated complex structure prediction by AlphaFold2
    out_dir_mut_complx_struct_pred_af2 = os.path.join(root_path, 'dataset/postproc_data/alphafold2_io/mut_complx_struct_pred_out')

    for dim_prot_complx_nm in input_dict['dim_prot_complx_nm_lst']:
        # trigger the actual postprocessing as per the postproc_stage
        if(postproc_stage == '2_mut_seq_struct_pred_by_af2'):
            run_postproc_2_mut_seq_struct_pred_by_af2(root_path = input_dict['root_path'], dim_prot_complx_nm = dim_prot_complx_nm
                                    , cuda_index = input_dict['cuda_index']
                                    , af2_exec_mode = input_dict['af2_exec_mode']
                                        , af2_num_recycle = input_dict['af2_num_recycle'], af2_num_ensemble = input_dict['af2_num_ensemble']
                                    , af2_num_seeds = input_dict['af2_num_seeds'], af2_overwrite_existing_results = input_dict['af2_overwrite_existing_results']
                                    , inp_dir_mut_seq_struct_pred_af2 = inp_dir_mut_seq_struct_pred_af2, out_dir_mut_seq_struct_pred_af2 = out_dir_mut_seq_struct_pred_af2)
        elif(postproc_stage == '5_mut_complx_struct_pred_by_af2'):
            run_postproc_5_mut_complx_struct_pred_by_af2(root_path = input_dict['root_path'], dim_prot_complx_nm = dim_prot_complx_nm
                                    , cuda_index = input_dict['cuda_index'], pdb_file_location = input_dict['pdb_file_location']
                                    , af2_exec_mode = input_dict['af2_exec_mode']
                                        , af2_num_recycle = input_dict['af2_num_recycle'], af2_num_ensemble = input_dict['af2_num_ensemble']
                                    , af2_num_seeds = input_dict['af2_num_seeds'], af2_overwrite_existing_results = input_dict['af2_overwrite_existing_results']
                                    , inp_dir_mut_seq_struct_pred_af2 = inp_dir_mut_seq_struct_pred_af2
                                    , inp_dir_mut_complx_struct_pred_af2 = inp_dir_mut_complx_struct_pred_af2
                                    , out_dir_mut_complx_struct_pred_af2 = out_dir_mut_complx_struct_pred_af2)
    # end of for loop: for dim_prot_complx_nm in input_dict['dim_prot_complx_nm_lst']:
    print('inside trigger_pd_postproc() method - End')


if __name__ == '__main__':
    root_path = os.path.join('/project/root/directory/path/here')
    # root_path = os.path.join('/scratch/pralaycs/Shubh_Working_Remote/PPI_Wkspc/PPI_Code/matpip_pd_prj')
    root_path = os.path.join('/home/suvra/SG_working/workspaces/matpip_pd_prj')
    

    # Different post-processing stages are:
    # 1_just_after_simuln, 2_mut_seq_struct_pred_by_af2, 3_mut_seq_struct_compare
    # 4_mut_seq_struct_overlay_for_complx_formn, 5_mut_complx_struct_pred_by_af2
    # 6_mut_complx_struct_simln_using_MD
    # postproc_stage_lst = ['1_just_after_simuln', '2_mut_seq_struct_pred_by_af2', '3_mut_seq_struct_compare', '4_mut_seq_struct_overlay_for_complx_formn'
    #                       , '5_mut_complx_struct_pred_by_af2', '6_mut_complx_struct_simln_using_MD']

    # postproc_stage_lst = ['5_mut_complx_struct_pred_by_af2']
    postproc_stage_lst = ['5_mut_complx_struct_pred_by_af2']

    user_input_dict = {}
    user_input_dict['cuda_index'] = 0
    user_input_dict['dim_prot_complx_nm_lst'] = ['2I25']

    user_input_dict['af2_num_recycle'] = 1  #
    user_input_dict['af2_num_seeds'] = 1  #
    
    # iterate over each of the post-processing stages
    for postproc_stage in postproc_stage_lst:
        trigger_pd_postproc(root_path=root_path, postproc_stage=postproc_stage, user_input_dict=user_input_dict)
